@page "/TicTacToe"

@inject IJugadoresApiService jugadoresApiService
@inject IPartidasApiService partidasApiService
@inject IMovimientosApiService movimientosApiService

<div class="container mx-auto max-w-lg p-6 bg-white rounded-lg shadow-xl text-center">
    <div class="game-container">
        @if (!gameStarted)
        {
            <div class="selection-screen">
                <h1>Elige tu jugador</h1>

                <div class="mb-3">
                    <label class="form-label fw-bold">Jugador X</label>
                    <InputSelect class="form-select" @bind-Value="jugadorXId">
                        <option value="0">--- Seleccione jugador X ---</option>
                        @foreach (var jugador in listaJugadores)
                        {
                            <option value="@jugador.JugadorId" disabled="@(jugador.JugadorId == jugadorOId)">
                                @jugador.Nombres
                            </option>
                        }
                    </InputSelect>
                </div>

                <div class="mb-3">
                    <label class="form-label fw-bold">Jugador O</label>
                    <InputSelect class="form-select" @bind-Value="jugadorOId">
                        <option value=""> --- Seleccione jugador O --- </option>
                        @foreach (var jugador in listaJugadores)
                        {
                            <option value="@jugador.JugadorId" disabled="@(jugador.JugadorId == jugadorXId)">
                                @jugador.Nombres
                            </option>
                        }
                    </InputSelect>
                </div>

                <button class="btn btn-success btn-lg mt-4"
                        disabled="@(jugadorXId == 0 || jugadorXId == jugadorOId)"
                        @onclick="StartGame">
                    Iniciar Partida
                </button>

                <hr class="my-4" />

                <h4>Unirse a Partida Existente</h4>
                <p class="fs-12">
                    Para conectarse como espectador, no es necesario elegir los jugadores, solamente el rol.
                    <br />
                    Para reconectarse como jugador X, solo es necesario elegir el jugador X arriba y el rol correspondiente.
                    <br />
                    Para conectarse como jugador O debe seleccionar el jugador X de la partida y 
                    el jugador O con el desea unirse o reconectarse <br /> y el rol correspondiente.
                </p>
  
                <div class="form-group mb-3">
                    <label>ID de la Partida:</label>
                    <div class="input-group">
                        <input id="partidaId" type="number" class="form-control" @bind="partidaId" placeholder="ID de la partida" />
                        <button class="btn btn-outline-secondary" type="button" @onclick="OpenPartidasModal">
                            <span class="bi-search-icon"></span>
                        </button>
                    </div>
                </div>

                <div class="mb-3">
                    <label class="form-label">Conectarse como:</label>
                    <InputSelect class="form-select" @bind-Value="rolSeleccionado">
                        <option value="">--- Seleccione rol ---</option>
                        <option value="X">Jugador X</option>
                        <option value="O">Jugador O</option>
                        <option value="Espectador">Espectador</option>
                    </InputSelect>
                </div>

                <button class="btn btn-warning btn-lg mt-2"
                        disabled="@(partidaId <= 0)"
                        @onclick="JoinGame">
                    Unirse a Partida
                </button>

                @if (!string.IsNullOrWhiteSpace(errorMessage))
                {
                    <div class="alert alert-danger mt-3">@errorMessage</div>
                }

            </div>
        } else
        {
            <div class="game-screen">
                <h2>Partida: @partidaId</h2>
                <h4 class="game-status">@gameStatus</h4>

                <div class="game-board">
                    @for (var i = 0; i < 9; i++)
                    {
                        var cellIndex = i; // Copia local para evitar problemas con el closure en el lambda
                        <button class="cell @GetPlayerClass(board[cellIndex])"
                        @onclick="() => HandleCellClick(cellIndex)"
                            disabled="@(!puedeJugar || _currentPlayerType != miSimbolo || board[cellIndex] != null || winner != null || esEmpate)">
                            @board[cellIndex]?.ToString()
                        </button>
                    }
                </div>

                <div class="mt-4">
                    <button class="btn btn-info me-2" @onclick="RefreshGameState" disabled="@refreshing">
                        @if (refreshing)
                        {
                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                            <span> Cargando...</span>
                        }
                        else
                        {
                            <span>🔄 Refrescar Estado</span>
                        }
                    </button>

                    <button class="btn btn-secondary" @onclick="LeaveGame">
                        Salir de la Partida
                    </button>
                </div>
            </div>
        }
    </div>
</div>

<PartidasModal IsOpen="showModal"
               IsOpenChanged="(value) => showModal = value"
               OnPartidaSelected="HandlePartidaSelected" />

@code {
    private List<JugadorResponse>? listaJugadores = [];
    private int jugadorXId;
    private int? jugadorOId;
    private int partidaId;

    private string? jugador1Nombre;
    private string? jugador2Nombre;

    private bool gameStarted = false;
    private bool puedeJugar = true;
    private string? errorMessage;
    private bool refreshing = false;

    private enum PlayerType { X, O }
    private PlayerType?[] board = new PlayerType?[9];
    private PlayerType _currentPlayerType = PlayerType.X;
    private PlayerType miSimbolo;
    private PlayerType? winner;
    private string rolSeleccionado = "";
    private bool esEmpate;
    private bool showModal = false;

    private PeriodicTimer? _refreshTimer;
    private bool _autoRefreshRunning = false;

    private string gameStatus
    {
        get
        {
            if (winner != null)
                return $"🏆 ¡Ganador: {GetNombreJugador(winner.Value)}!";
            else if (esEmpate)
                return "🤝 ¡Empate!";
            else
                return $"Turno de: {GetNombreJugador(_currentPlayerType)}";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var result = await jugadoresApiService.GetJugadoresAsync();

        if (result is Resource<List<JugadorResponse>>.Success ok)
        {
            listaJugadores = ok.Data;
        }
        else if (result is Resource<List<JugadorResponse>>.Error err)
        {
            errorMessage = err.Message;
        }
    }

    private async Task StartGame()
    {
        var response = await partidasApiService.PostPartida(jugadorXId, jugadorOId);

        if (response is Resource<PartidaResponse>.Error error)
        {
            errorMessage = $"Error al crear la partida: {error.Message}";
            return;
        }


        partidaId = response.Data?.PartidaId ?? 0;

        jugador1Nombre = listaJugadores.FirstOrDefault(j => j.JugadorId == jugadorXId)?.Nombres;
        jugador2Nombre = listaJugadores.FirstOrDefault(j => j.JugadorId == jugadorOId)?.Nombres;

        gameStarted = true;
        miSimbolo = PlayerType.X;
        StartAutoRefresh();
    }

    private async Task JoinGame()
    {
        if (string.IsNullOrWhiteSpace(rolSeleccionado))
        {
            errorMessage = "Selecciona un rol para unirte a la partida.";
            return;
        }

        var response = await partidasApiService.GetPartidaAsync(partidaId);
        if (response is Resource<PartidaResponse>.Error error)
        {
            errorMessage = $"Error al unirse a la partida: {error.Message}";
            return;
        }

        var partida = response.Data;

        if (rolSeleccionado == "Espectador")
        {
            puedeJugar = false;
            miSimbolo = default;
        }
        else if (rolSeleccionado == "X")
        {
            if (jugadorXId != partida.Jugador1Id)
            {
                errorMessage = "❌ Solo el jugador X original puede unirse como X.";
                return;
            }

            miSimbolo = PlayerType.X;
            puedeJugar = true;
        }
        else if (rolSeleccionado == "O")
        {
            if (jugadorXId != partida.Jugador1Id)
            {
                errorMessage = "❌ Jugador X seleccionado debe coincidir con el original.";
                return;
            }

            if (partida.Jugador2Id == null || partida.Jugador2Id == 0)
            {
                var updateResponse = await partidasApiService.PutPartida(partidaId, jugadorXId, jugadorOId.Value);
                if (updateResponse is Resource<PartidaResponse>.Error err)
                {
                    errorMessage = $"No se pudo unir como jugador O: {err.Message}";
                    return;
                }
            }
            else
            {
                if (partida.Jugador2Id != jugadorOId)
                {
                    errorMessage = "❌ Jugador O ya está ocupado por otro jugador.";
                    return;
                }
            }

            miSimbolo = PlayerType.O;
            puedeJugar = true;
        }

        jugador1Nombre = listaJugadores.FirstOrDefault(j => j.JugadorId == jugadorXId)?.Nombres;
        jugador2Nombre = listaJugadores.FirstOrDefault(j => j.JugadorId == jugadorOId)?.Nombres;

        gameStarted = true;
        StartAutoRefresh();
        await RefreshGameState();
    }

    private async Task HandleCellClick(int index)
    {
        // Ignorar si la celda está ocupada o el juego terminó
        if (!puedeJugar || _currentPlayerType != miSimbolo || board[index] != null || winner != null || esEmpate)
        {
            return;
        }

        int fila = index / 3;
        int columna = index % 3;

        var result = await movimientosApiService.PostMovimiento(
            partidaId,
            _currentPlayerType == PlayerType.X ? "X" : "O",
            fila,
            columna
        );

        if (result is Resource<MovimientoResponse>.Error err)
        {
            errorMessage = $"Error al registrar el movimiento: {err.Message}";
            return;
        }

        await RefreshGameState();
    }

    private async Task RefreshGameState()
    {
        refreshing = true;

        var response = await movimientosApiService.GetMovimientoAsync(partidaId);
        if (response is Resource<List<MovimientoResponse>>.Success ok)
        {
            board = new PlayerType?[9];
            foreach (var mov in ok.Data)
            {
                var index = mov.PosicionFila * 3 + mov.PosicionColumna;
                board[index] = mov.Jugador == "X" ? PlayerType.X : PlayerType.O;
            }

            // Determinar de quién es el turno
            int countX = board.Count(c => c == PlayerType.X);
            int countO = board.Count(c => c == PlayerType.O);
            _currentPlayerType = countX > countO ? PlayerType.O : PlayerType.X;

            winner = CheckForWinner();
            esEmpate = board.All(cell => cell != null) && winner == null;
        }
        else if (response is Resource<List<MovimientoResponse>>.Error err)
        {
            errorMessage = $"Error al refrescar: {err.Message}";
        }

        refreshing = false;
    }

    private PlayerType? CheckForWinner()
    {
        var winningLines = new[]
        {
             new[] {0, 1, 2}, new[] {3, 4, 5}, new[] {6, 7, 8},// Horizontales
             new[] {0, 3, 6}, new[] {1, 4, 7}, new[] {2, 5, 8},// Verticales
             new[] {0, 4, 8}, new[] {2, 4, 6}// Diagonales
        };

        foreach (var line in winningLines)
        {
            var (a, b, c) = (line[0], line[1], line[2]);
            if (board[a].HasValue && board[a] == board[b] && board[a] == board[c])
            {
                return board[a];
            }
        }

        return null; // No hay ganador
    }

    private string GetPlayerClass(PlayerType? player)
    {
        if (!player.HasValue) return "";
        return player == PlayerType.X ? "player-x" : "player-o";
    }

    private string GetNombreJugador(PlayerType player)
    {
        return player == PlayerType.X
            ? jugador1Nombre ?? "Jugador X"
            : jugador2Nombre ?? "Jugador O";
    }

    private void LeaveGame()
    {
        StopAutoRefresh();
        gameStarted = false;
        partidaId = 0;
        jugadorXId = 0;
        jugadorOId = null;
        rolSeleccionado = "";
        board = new PlayerType?[9];
        _currentPlayerType = PlayerType.X;
        winner = null;
        esEmpate = false;
        puedeJugar = true;
        errorMessage = null;
    }

    private void OpenPartidasModal()
    {
        showModal = true;
    }

    private void HandlePartidaSelected(int _partidaId)
    {
        partidaId = _partidaId;
    }

    private async Task StartAutoRefresh()
    {
        if (_autoRefreshRunning)
            return;

        _autoRefreshRunning = true;
        _refreshTimer = new PeriodicTimer(TimeSpan.FromSeconds(3));

        try
        {
            while (await _refreshTimer.WaitForNextTickAsync() && gameStarted)
            {
                await RefreshGameState();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {

        }
        finally
        {
            _autoRefreshRunning = false;
        }
    }

    private void StopAutoRefresh()
    {
        _refreshTimer?.Dispose();
        _refreshTimer = null;
        _autoRefreshRunning = false;
    }
}
