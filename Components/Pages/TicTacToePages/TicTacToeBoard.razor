@page "/TicTacToe/Board/{PartidaId:int}/{RolSeleccionado}"

@inject IMovimientosApiService movimientosApiService
@inject IPartidasApiService partidasApiService
@inject NavigationManager navigationManager
@rendermode InteractiveServer

<div class="container mx-auto max-w-lg p-6 bg-white rounded-lg shadow-xl text-center">

    <div class="game-container">
        <div class="game-screen">
            <h2>Partida: @PartidaId</h2>
            <h2 class="game-status">@gameStatus</h2>

            <div class="game-board">
                @for (var i = 0; i < 9; i++)
                {
                    var cellIndex = i; // Copia local para evitar problemas con el closure en el lambda
                    <button class="cell @GetPlayerClass(board[cellIndex])"
                        @onclick="() => HandleCellClick(cellIndex)"
                        disabled="@(!puedeJugar || _currentPlayerType != miSimbolo || board[cellIndex] != null || winner != null || esEmpate)">
                        @board[cellIndex]?.ToString()
                    </button>
                }
            </div>

            @if (!string.IsNullOrEmpty(errorMensaje))
            {
                <div class="alert alert-danger">@errorMensaje</div>
            }

            <button class="btn btn-secondary mt-4" @onclick="ExitGame">
                Salir del Juego
            </button>
        </div>
    </div>
</div>

@code {
    [Parameter] 
    public int PartidaId { get; set; }

    [Parameter]
    public string RolSeleccionado { get; set; }

    private int jugadorXId;
    private int? jugadorOId;

    private bool puedeJugar = true;
    private string errorMensaje = string.Empty;

    private enum PlayerType { X, O }
    private PlayerType?[] board = new PlayerType?[9];
    private PlayerType _currentPlayerType;
    private PlayerType miSimbolo;
    private PlayerType? winner;
    private bool esEmpate;

    private PeriodicTimer? _refreshTimer;
    private bool _autoRefreshRunning = false;


    private string gameStatus
    {
        get
        {
            if (winner != null) return $"🏆 ¡Ganador: {winner.Value}!";
            if (esEmpate) return "🤝 ¡Es un empate!";
            return $"Turno de: {_currentPlayerType}";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var response = await partidasApiService.GetPartidaAsync(PartidaId);
        if (response is Resource<PartidaResponse>.Error error)
        {
            errorMensaje = $"Error al unirse a partida: {error.Message}";
            return;
        }

        var partida = response.Data;

        jugadorXId = partida.Jugador1Id;
        jugadorOId = partida.Jugador2Id;

        if (RolSeleccionado == "Espectador")
        {
            puedeJugar = false;
            miSimbolo = default;
        }
        else if (RolSeleccionado == "O")
        {
            miSimbolo = PlayerType.O;
            puedeJugar = true;
        } 
        else if (RolSeleccionado == "X")
        {
            miSimbolo = PlayerType.X;
            puedeJugar = true;
        }

        StartAutoRefresh();
        await RefreshGameState();
    }

    private async Task HandleCellClick(int index)
    {
        if (!puedeJugar || _currentPlayerType != miSimbolo || board[index] != null || winner != null || esEmpate)
        {
            return;
        }

        int fila = index / 3;
        int columna = index % 3;

        var result = await movimientosApiService.PostMovimiento(
            PartidaId,
            _currentPlayerType == PlayerType.X ? "X" : "O",
            fila,
            columna
        );

        if (result is Resource<MovimientoResponse>.Error err)
        {
            errorMensaje = $"Error al registrar el movimiento: {err.Message}";
            return;
        }

        await RefreshGameState();
    }

    private async Task RefreshGameState()
    {
        var response = await movimientosApiService.GetMovimientoAsync(PartidaId);
        if (response is Resource<List<MovimientoResponse>>.Success ok)
        {
            board = new PlayerType?[9];
            foreach (var mov in ok.Data)
            {
                var index = mov.PosicionFila * 3 + mov.PosicionColumna;
                board[index] = mov.Jugador == "X" ? PlayerType.X : PlayerType.O;
            }

            // Determinar de quién es el turno
            int countX = board.Count(c => c == PlayerType.X);
            int countO = board.Count(c => c == PlayerType.O);
            _currentPlayerType = countX > countO ? PlayerType.O : PlayerType.X;

            winner = CheckForWinner();
            esEmpate = board.All(cell => cell != null) && winner == null;
        }
        else if (response is Resource<List<MovimientoResponse>>.Error err)
        {
            errorMensaje = $"Error al refrescar: {err.Message}";
        }
    }

    private PlayerType? CheckForWinner()
    {
        var winningLines = new[]
        {
             new[] {0, 1, 2}, new[] {3, 4, 5}, new[] {6, 7, 8},// Horizontales
             new[] {0, 3, 6}, new[] {1, 4, 7}, new[] {2, 5, 8},// Verticales
             new[] {0, 4, 8}, new[] {2, 4, 6}// Diagonales
        };

        foreach (var line in winningLines)
        {
            var (a, b, c) = (line[0], line[1], line[2]);
            if (board[a].HasValue && board[a] == board[b] && board[a] == board[c])
            {
                return board[a];
            }
        }

        return null; // No hay ganador
    }

    private void ExitGame()
    {
        navigationManager.NavigateTo("/TicTacToe/Selection");
    }

    private string GetPlayerClass(PlayerType? player)
    {
        if (!player.HasValue) return "";
        return player == PlayerType.X ? "player-x" : "player-o";
    }

    private async Task StartAutoRefresh()
    {
        if (_autoRefreshRunning)
            return;

        _autoRefreshRunning = true;
        _refreshTimer = new PeriodicTimer(TimeSpan.FromSeconds(3));

        try
        {
            while (await _refreshTimer.WaitForNextTickAsync())
            {
                await RefreshGameState();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {

        }
        finally
        {
            _autoRefreshRunning = false;
        }
    }
}